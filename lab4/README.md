# Лабораторная работа №4

**Описание предметной области, по которой должна быть построена объектная модель:**

> Шурупчик нажал еще одну кнопку, и, к изумлению зрителей, гамак начал медленно опускаться. Он опускался до тех пор,
> пока лежавший в нем Шурупчик не растянулся на полу.
> Шурупчик принялся ходить по комнате и нажимать разные кнопки, в результате чего откидывались новые столы, стулья и
> полки, открывались дверцы различных шкафов и кладовушек. Наконец он нажал еще одну кнопку и провалился в подполье.
>
> -Идите сюда! - послышался через минуту со двора его голос.
>
> Друзья вышли во двор.
>
> -Здесь у меня гараж, - сказал Шурупчик, подводя Винтика и Шпунтика к каменному сараю с широкой железной дверью.
>
**Программа должна удовлетворять следующим требованиям:**

1. В программе должны быть реализованы 2 собственных класса исключений (checked и unchecked), а также обработка
   исключений этих классов.
2. В программу необходимо добавить использование локальных, анонимных и вложенных классов (static и non-static).

**Порядок выполнения работы:**

1. Доработать объектную модель приложения.
2. Перерисовать диаграмму классов в соответствии с внесёнными в модель изменениями.
3. Согласовать с преподавателем изменения, внесённые в модель.
4. Модифицировать программу в соответствии с внесёнными в модель изменениями.

## Что добавилось в 4 лабораторной по сравнению с 3?

1. Добавлен package **exception** с классами **PushableAlreadyPushedException** и **WrongGamakHeightException**.

* класс **PushableAlreadyPushedException** создан для обработки исключений типа **checked**. Гениальная концепция
  такова:
  нельзя откинуть предмет, который уже был откинут, потому что заедает кнопка.У меня такие предметы - это столы, стулья,
  полки (их наш шизоидный Шурупчик push в соответствии с текстом "Шурупчик принялся ходить по комнате и нажимать разные
  кнопки, в результате чего откидывались новые столы, стулья и полки...").
  Соответственно в классах **Chair**, **Table** и **Shelf** в методе **push()** выбрасывается исключение. Обработка
  этого исключения происходит в классе
  **PushFurnitureButton**.


* класс **WrongGamakHeightException** создан для обработки исключений типа **unchecked**. Еще более гениальная концепция
  такова: наш гамак,
  который опускается до пола при нажатии кнопки класса **GamakButton**, очевидно можно опуститься до высоты равной 0.
  Но если вдруг кто-то решит опустить гамак на отрицательную высоту (соболезную),
  то бубубу прога, конечно, скомпилириуется,
  но получим вот такое исключение при выполнении:
  ![unchecked exception](unchecked_exception.png)
  Исключение выбрасывается в классе **Gamak** в методе **lower()**.

2. Добавлены такие классы как:

* non-static класс **Door** в классе **Barn**
* static класс **SpaceBounds** в классе **Space**
* класс-анонимус (искать так:**private final List<Human> visitors = new ArrayList<>()**) в классе **Plot**
* локальный класс **HumanMouth** в классе **Human**

Теперь о каждом нашем гробу на колесах поподробнее:

* non-static класс **Door** в классе **Barn**. Дверь в соответствии с текстом "...подводя Винтика и Шпунтика к каменному
  сараю с широкой железной дверью."
  принадлежит непосредственно сараю, что и демонстрируется использованием нестатического вложенного класса.
  Сама дверь - это физический объект, который может открываться, поэтому **public class Door extends PhysicalObject
  implements Openable**.
  Более того, во вложенном нестатическом классе **Door** мы используем приватное поле  **private boolean isOpen**
  внешнего класса **Barn**.
  А также в конструкторе класса **Barn** мы, конечно, создаем объект дверь, тем самым показывая, что дверь принадлежит
  именно сараю.
  Таким образом, продемонстрирована тесная связь между объектом внутреннего и внешнего класса.


* static класс **SpaceBounds** в классе **Space**, который создан для задания размера, а конкретно площадей различных
  помещений.
  Таким образом мы скрываем часть логики внутри класса. Теперь мы уже в конструктор различных помещений будем передавать
  объект статического класса, например, в классе **Basement**:

  ![example_static_class.png](example_static_class.png)

* класс-анонимус (искать так:**private final List<Human> visitors = new ArrayList<>()**) в классе **Plot**
  Раньше это было организовано просто через массивы, а теперь будем использовать списки, ура, растем!


* локальный класс **HumanMouth** в классе **Human**. Начались танцы с бубном. В конструктор класса **Human** добавим
  наш локальный класс "человеческий рот", который реализует интерфейс **Speaking**. Рот будет привязан к человеку, и
  он может говорить, но от остальных методов реализация того, что умеет рот, будет скрыта)).умные мысли часто преследуют
  меня, но я быстрее, как говорится.
  Тут можно было использовать анонимный класс вместо локального.

3. Конечно же добавим таких персонажей как Шпунтик и Винтик - друзей Шурупчика и продолжим наш сюжет.
   Герои входят и выходят из различных помещений и что-то произносят (это и пропишем в конце класса **Plot**).
   "-Идите сюда! - послышался через минуту со двора его голос." - для этого добавим в класс **Plot**

   ![waiting.png](waiting.png)

и т.д. Интересно, мог бы подумать автор данной детской книги о том, как в будущем будут использовать его произведение..

## Reminder: как была реализована лабораторная 3.

Для начала стоит сказать, что в коде иногда проскальзывают мои авторские замечания, возможно не слишком
умные и корректные.

Были созданы базовые абстрактные классы для базовых сущностей:

1. Класс **PhysicalObject** - предназначен для любых физических вещей в повествовании, имеет размер, материал и цвет.
   Материал и цвет являются перечислимыми типами (**Enum**).
2. Класс **Human** - предназначен для персонажей в повестовании, имеет возраст, высоту, вес и имя.
3. Класс **Room** - предназначен для какого-либо помещения, содержит в себе список объектов и персонажей, а также
   размеры самого помещения.

Были созданы классы конкретных объектов, которые наследуются от этих абстрактных классов, например:

1. **Basement** для помещения подвала, который наследуется от **Room**
2. **Chair** для стула, который наследуется от **Furniture** (родительский класс для любой мебели), который наследуется
   от **PhysicalObject**.

Также, чтобы объединить общее поведение некоторых классов были созданы интерфейсы:

1. Интерфейс **Pushable** - содержит метод **push()**, используется в тех классах мебели, которую можно пнуть (раскидать
   по комнате).
2. Интерфейс **Openable** - содержит методы **open()** и **close()**, используется в классах объектов, которые можно
   открыть или закрыть. Например, шкаф или подвал.
3. Интерфейс **Interactible** - содержит метод **interact()**, используется в классах объектов, с которыми могут
   взаимодействовать персонажи. В нашем случае - это только кнопки **Button**.

Чтобы объединить всё это есть класс **Plot**. В его конструкторе мы создаем обстановку (окружение), а в методе **run()**
происходит сюжетное действие и вызываются соответствующие методы различных объектов.
При этом одни объекты могут воздействовать на другие, например, вызов **OpenCloseButton.interact()** ("Шурупчик нажимал
разные кнопки") может привести к вызову **Closet.open()** ("открывались дверцы различных шкафов")

## Диаграмма классов реализованной объектной модели.

![uml image](uml.png)

